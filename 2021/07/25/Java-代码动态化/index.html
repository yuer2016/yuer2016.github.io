<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>Java 代码动态化 | 小鱼儿博客</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="小鱼儿博客" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="/plugins/highlight/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();
</script><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">小鱼儿博客</a></h1></div><p class="m-desc">是非，审之于己；毁誉，听之于人； 得失，安之于数；</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">Java 代码动态化</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2021/07/25/Java-%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E5%8C%96/">2021-07-25</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><p>基本上，有四个步骤可以使Java代码动态化:</p>
<ol>
<li>部署选定的源代码并监视文件更改</li>
<li>在运行时编译Java代码</li>
<li>在运行时加载/重新加载Java类</li>
<li>将最新的类链接到其调用者</li>
</ol>
<h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>要开始编写一些动态代码，我们必须回答的第一个问题是：“代码的哪一部分应该是动态的？整个应用程序还是某些类？”从技术上讲，没有什么限制。您可以在运行时加载/重新加载任何Java类。但是在大多数情况下，只有部分代码需要这种级别的灵活性。</p>
<p>在接口的后面，只要符合接口定义的协定，就可以自由更改实现。这正是我们动态类所需的质量。简而言之：选择实现类作为动态类。</p>
<h3 id="监视源代码修改"><a href="#监视源代码修改" class="headerlink" title="监视源代码修改"></a>监视源代码修改</h3><p>通过比较修改时间戳和文件大小，可以检测到文件更改。 对于我们的示例，每次在Postman接口上调用方法时，都会对PostmanImpl.java进行检查。 或者，您可以在后台生成守护程序线程以定期检查文件更改。 这可能会为大型应用程序带来更好的性能。</p>
<h3 id="在运行时编译Java代码"><a href="#在运行时编译Java代码" class="headerlink" title="在运行时编译Java代码"></a>在运行时编译Java代码</h3><p>在检测到源代码更改后，我们来解决编译问题。 通过将实际工作委派给现有的Java编译器，运行时编译可以轻而易举。 有许多Java编译器可供使用，但是在本文中，我们使用Sun的Java Platform Standard Edition中包含的Javac编译器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errorCode = com.sun.tools.javac.Main.compile(<span class="keyword">new</span> String[] &#123;</span><br><span class="line">            <span class="string">&quot;-classpath&quot;</span>, <span class="string">&quot;bin&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-d&quot;</span>, <span class="string">&quot;/temp/dynacode_classes&quot;</span>,</span><br><span class="line">            <span class="string">&quot;dynacode/sample/PostmanImpl.java&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>com.sun.tools.javac.Main类是Javac编译器的编程接口。 它提供了编译Java源文件的静态方法。 执行上面的语句与从命令行以相同的参数运行javac具有相同的效果。 它使用指定的类路径bin编译源文件dynacode / sample / PostmanImpl.java，并将其类文件输出到目标目录/ temp / dynacode_classes。 返回一个整数作为错误代码。 零意味着成功；零意味着成功。 其他数字表示出了问题。</p>
<p>com.sun.tools.javac.Main 类还提供了另一个compile（）方法，该方法接受附加的PrintWriter参数，如下面的代码所示。 如果编译失败，则会将详细的错误消息写入PrintWriter。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Defined in com.sun.tools.javac.Main</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compile</span><span class="params">(String[] args)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compile</span><span class="params">(String[] args, PrintWriter out)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="在运行时加载-重新加载Java类"><a href="#在运行时加载-重新加载Java类" class="headerlink" title="在运行时加载/重新加载Java类"></a>在运行时加载/重新加载Java类</h3><p>必须先加载已编译的类，然后才能生效。 Java在类加载方面很灵活。 它定义了一个全面的类加载机制，并提供了一些类加载器的实现。</p>
<p>下面的示例代码显示了如何加载和重新加载类。 基本思想是使用我们自己的URLClassLoader加载动态类。 每当更改并重新编译源文件时，我们都会丢弃旧的类（以供以后进行垃圾回收），并创建一个新的URLClassLoader来再次加载该类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The dir contains the compiled classes.</span></span><br><span class="line">    File classesDir = <span class="keyword">new</span> File(<span class="string">&quot;/temp/dynacode_classes/&quot;</span>);</span><br><span class="line">    <span class="comment">// The parent classloader</span></span><br><span class="line">    ClassLoader parentLoader = Postman.class.getClassLoader();</span><br><span class="line">    <span class="comment">// Load class &quot;sample.PostmanImpl&quot; with our own classloader.</span></span><br><span class="line">    URLClassLoader loader1 = <span class="keyword">new</span> URLClassLoader(</span><br><span class="line">            <span class="keyword">new</span> URL[] &#123; classesDir.toURL() &#125;, parentLoader);</span><br><span class="line">    Class cls1 = loader1.loadClass(<span class="string">&quot;sample.PostmanImpl&quot;</span>);</span><br><span class="line">    Postman postman1 = (Postman) cls1.newInstance();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke on postman1 ...</span></span><br><span class="line"><span class="comment">     * Then PostmanImpl.java is modified and recompiled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// Reload class &quot;sample.PostmanImpl&quot; with a new classloader.</span></span><br><span class="line">    URLClassLoader loader2 = <span class="keyword">new</span> URLClassLoader(</span><br><span class="line">            <span class="keyword">new</span> URL[] &#123; classesDir.toURL() &#125;, parentLoader);</span><br><span class="line">    Class cls2 = loader2.loadClass(<span class="string">&quot;sample.PostmanImpl&quot;</span>);</span><br><span class="line">    Postman postman2 = (Postman) cls2.newInstance();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Work with postman2 from now on ...</span></span><br><span class="line"><span class="comment">     * Don&#x27;t worry about loader1, cls1, and postman1</span></span><br><span class="line"><span class="comment">     * they will be garbage collected automatically.</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<p>创建自己的类加载器时，请注意parentLoader。 基本上，规则是父类加载器必须提供子类加载器所需的所有依赖项。 因此，在示例代码中，动态类PostmanImpl依赖于接口Postman。 这就是为什么我们使用Postman的类加载器作为父类加载器。</p>
<p>我们距离完成动态代码还有一步之遥。 回想一下前面介绍的示例。 在那里，动态类重新加载对其调用者是透明的。 但是在上面的示例代码中，当代码更改时，我们仍然必须将服务实例从postman1更改为postman2。 第四步（也是最后一步）将消除此手动更改的需要。</p>
<h3 id="将最新的类链接到其调用者"><a href="#将最新的类链接到其调用者" class="headerlink" title="将最新的类链接到其调用者"></a>将最新的类链接到其调用者</h3><p>如何使用静态引用访问最新的动态类？ 显然，直接（正常）引用动态类的对象不会成功。 我们需要在客户端和动态类之间建立一个代理。</p>
<p>在此，代理是充当动态类的访问接口的类。 客户端不直接调用动态类；而是直接调用动态类。 代理代替。 然后，代理将调用转发到后端动态类。</p>
<p>Java Reflection API包含一个用于创建代理的便捷实用程序。 类java.lang.reflect.Proxy提供了静态方法，使您可以为任何Java接口创建代理实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler handler = <span class="keyword">new</span> DynaCodeInvocationHandler(...);</span><br><span class="line">    Postman proxy = (Postman) Proxy.newProxyInstance(</span><br><span class="line">                Postman.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123; Postman.class &#125;,</span><br><span class="line">                handler);</span><br></pre></td></tr></table></figure>

<p>返回的代理是匿名类的对象，该匿名类与Postman接口（newProxyInstance（）方法的第一个参数）共享相同的类加载器，并实现Postman接口（第二个参数）。 代理实例上的方法调用将分派到处理程序的invoke（）方法（第三个参数）。 处理程序的实现可能如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynaCodeInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Get an instance of the up-to-date dynamic class</span></span><br><span class="line">        Object dynacode = getUpToDateInstance();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Forward the invocation</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(dynacode, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invoke（）方法获取最新动态类的实例，并将调用转发给它。 如果动态类的源文件已被修改，则这可能涉及源代码编译和类重载。</p>
<p>现在，我们已经完成了Postman服务的动态代码。 客户端创建服务的代理，并通过该代理调用方法DeliveryMessage（）。 代理上的每次调用都分派到DynaCodeInvocationHandler类的invoke（）方法。 在该方法中，首先获得了最新的服务实现，其中可能涉及必要的源代码编译和类重载。 然后，调用前进到实现以进行实际处理。</p>
<p>最后，我想讨论一下动态代码的价值和应用：动态代码可以快速响应按需更改请求。它可用于实现不时变化的真正的动态服务和业务规则，并替换工作流任务节点使用的嵌入式脚本。动态代码还简化了应用程序维护，并大大减少了由于应用程序重新部署而造成的停机。</p>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">yuer2016</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2021/07/25/Java-%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E5%8C%96/">https://yuer2016.github.io/2021/07/25/Java-代码动态化/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="https://yuer2016.github.io">yuer2016的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/java/">java</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">前提条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E8%A7%86%E6%BA%90%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9"><span class="toc-number">2.</span> <span class="toc-text">监视源代码修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%BC%96%E8%AF%91Java%E4%BB%A3%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text">在运行时编译Java代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A0%E8%BD%BD-%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BDJava%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">在运行时加载&#x2F;重新加载Java类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%9C%80%E6%96%B0%E7%9A%84%E7%B1%BB%E9%93%BE%E6%8E%A5%E5%88%B0%E5%85%B6%E8%B0%83%E7%94%A8%E8%80%85"><span class="toc-number">5.</span> <span class="toc-text">将最新的类链接到其调用者</span></a></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2021/07/25/OpenResty-%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2Vue-%E5%89%8D%E7%AB%AF/">&lt; OpenResty 安装部署Vue 前端</a><a class="next" href="/2021/07/25/centos7-%E5%AE%89%E8%A3%85-docker/">centos7 安装 docker &gt;</a></div><div id="valine-comment"><style type="text/css">.night .v[data-class=v] a { color: #0F9FB4 !important; }
.night .v[data-class=v] a:hover { color: #216C73 !important; }
.night .v[data-class=v] li { list-style: inherit; }
.night .v[data-class=v] .vwrap { border: 1px solid #223441; border-radius: 0; }
.night .v[data-class=v] .vwrap:hover { box-shadow: 0 0 6px 1px #223441; }
.night .v[data-class=v] .vbtn { border-radius: 0; background: none; }
.night .v[data-class=v] .vlist .vcard .vh { border-bottom-color: #293D4E; }
.night .v[data-class=v] .vwrap .vheader .vinput { border-bottom-color: #223441; }
.night .v[data-class=v] .vwrap .vheader .vinput:focus { border-bottom-color: #339EB4; }
.night .v[data-class=v] code, .night .v[data-class=v] pre,.night .v[data-class=v] .vlist .vcard .vhead .vsys { background: #203240 !important; }
.night .v[data-class=v] code, .night .v[data-class=v] pre { color: #F0F0F0; font-size: 95%; }
.v[data-class=v] .vcards .vcard .vh {border-bottom-color: #223441; }
.night .v[data-class=v] .vcards .vcard .vcontent.expand:before {background: linear-gradient(180deg,rgba(38,57,73,.4),rgba(38,57,73,.9));}
.night .v[data-class=v] .vcards .vcard .vcontent.expand:after {background: rgba(38,57,73,.9)}
</style><div id="vcomment"></div><script src="//cdn.bootcdn.net/ajax/libs/valine/1.4.14/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'',
  appKey:'',
  lang: 'zh-cn',
  placeholder:'ヾﾉ≧∀≦)o Come on, say something...',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></section><footer><p>Copyright © 2016 - 2021 <a href="/." rel="nofollow">小鱼儿博客</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>