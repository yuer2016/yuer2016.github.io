<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小鱼儿博客</title>
  
  
  <link href="https://yuer2016.github.io/atom.xml" rel="self"/>
  
  <link href="https://yuer2016.github.io/"/>
  <updated>2021-07-25T14:09:04.746Z</updated>
  <id>https://yuer2016.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis常用命令一览</title>
    <link href="https://yuer2016.github.io/2021/07/25/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/"/>
    <id>https://yuer2016.github.io/2021/07/25/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/</id>
    <published>2021-07-25T14:06:20.000Z</published>
    <updated>2021-07-25T14:09:04.746Z</updated>
    
    <content type="html"><![CDATA[<p>Redis可以存储键和五种不同的数据结构类型，分别为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String(字符串)、LIST(列表)、SET(集合)、 HASH(散列) 、ZSET(有序集合)</span><br></pre></td></tr></table></figure><p><strong>[注意：  Redis不区分大小写]</strong></p><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1. SET KEY VALUE</span><br><span class="line">   赋值</span><br><span class="line">    </span><br><span class="line">2. GET KEY</span><br><span class="line">   取值</span><br><span class="line">   </span><br><span class="line">3. DEL KEY</span><br><span class="line">   删除当前键值</span><br><span class="line">    </span><br><span class="line">4. INCR KEY</span><br><span class="line">   让当前值递增</span><br><span class="line">    </span><br><span class="line">5. INCRBY KEY</span><br><span class="line">   增加指定整数</span><br><span class="line">    </span><br><span class="line">6. DECR KEY</span><br><span class="line">   减少当前键值</span><br><span class="line">    </span><br><span class="line">7. DECRBY KEY</span><br><span class="line">   减少指定整数</span><br><span class="line">    </span><br><span class="line">8. KEYS *</span><br><span class="line">   获得所有Redis的键</span><br><span class="line">    </span><br><span class="line">9. EXISTS KEY</span><br><span class="line">   判断键是否存在，存在返回1，不存在返回0</span><br><span class="line">    </span><br><span class="line">10. INCRBYFLOAT KEY</span><br><span class="line">    增加指定浮点数</span><br><span class="line">    </span><br><span class="line">11. APPEND KEY VALUE</span><br><span class="line">    向尾部追加值</span><br><span class="line">    </span><br><span class="line">12. STRLEN KEY</span><br><span class="line">    获取字符串长度</span><br><span class="line">    </span><br><span class="line">13. MGET KEY ... ...</span><br><span class="line">    同时获取多个键值</span><br><span class="line">    </span><br><span class="line">14. MSET KEY VALUE ... ...</span><br><span class="line">    设置多个键值</span><br></pre></td></tr></table></figure><h3 id="HASH-散列"><a href="#HASH-散列" class="headerlink" title="HASH(散列)"></a>HASH(散列)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1. HSET KEY FIELD VALUE</span><br><span class="line">   散列赋值</span><br><span class="line">   </span><br><span class="line">2. HGET KEY FIELD</span><br><span class="line">   散列取值</span><br><span class="line">   </span><br><span class="line">3. HMSET KEY [FIELD VALUE ...]</span><br><span class="line">   散列设置多个字段值</span><br><span class="line">   </span><br><span class="line">4. HMGET KEY [FIELD ....]</span><br><span class="line">   获得散列多个字段</span><br><span class="line">   </span><br><span class="line">5. HGETALL KEY</span><br><span class="line">   获得散列key所有字段和值</span><br><span class="line">   </span><br><span class="line">6. HEXISIS KEY FIELD</span><br><span class="line">   判断字段是否存在</span><br><span class="line">   </span><br><span class="line">7. HSETNX KEY FIELD VALUE</span><br><span class="line">   当字段不存在时赋值</span><br><span class="line">   </span><br><span class="line">8. HINCRBY KEY FIELD INCREMENT</span><br><span class="line">   增加数字</span><br><span class="line">   </span><br><span class="line">9. HDEL KEY [FIELD ...]</span><br><span class="line">   删除字段</span><br><span class="line">   </span><br><span class="line">10.HKEYS KEY</span><br><span class="line">   获取字段名</span><br><span class="line">   </span><br><span class="line">11.HLEN KEY </span><br><span class="line">   获得字段数量</span><br><span class="line">   </span><br><span class="line">12.HVALS KEY</span><br><span class="line">   只获得字段值</span><br></pre></td></tr></table></figure><h3 id="LIST-列表类型"><a href="#LIST-列表类型" class="headerlink" title="LIST(列表类型)"></a>LIST(列表类型)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1. LPUSH KEY [VALUE ...]</span><br><span class="line">   向列表左侧添加元素</span><br><span class="line">   </span><br><span class="line">2. RPUSH KEY [VALUE ...]</span><br><span class="line">   向列表右侧添加元素</span><br><span class="line">   </span><br><span class="line">3. LPOP KEY</span><br><span class="line">    从左边弹出元素</span><br><span class="line">    </span><br><span class="line">4. RPOP KEY</span><br><span class="line">   从右边弹出元素</span><br><span class="line">   </span><br><span class="line">5. LLEN KEY</span><br><span class="line">   获取列表中的元素个数</span><br><span class="line">   </span><br><span class="line">6. LRANGE KEY START STOP</span><br><span class="line">   获取列表的片段[支持负索引，表示从右边开始]</span><br><span class="line">   </span><br><span class="line">7. LREM KEY COUNT VALUE</span><br><span class="line">   删除列表中前count个值为value的数据</span><br><span class="line">   当count&gt;0:从列表左边开始删除</span><br><span class="line">   当count&lt;0:从列表右边开始删除</span><br><span class="line">   当count=0:从列表删除值为value的元素</span><br><span class="line">   </span><br><span class="line">8. LINDEX KEY VALUE</span><br><span class="line">   获得指定索引的元素值</span><br><span class="line">   </span><br><span class="line">9. LSET KEY INDEX VALUE</span><br><span class="line">   设置指定索引的元素值</span><br><span class="line"></span><br><span class="line">10. LTRIM KEY START END</span><br><span class="line">    删除指定索引之外的所有元素</span><br><span class="line">    </span><br><span class="line">11. LINSERT KEY BEFORE | AFIER PIVOT VALUE</span><br><span class="line">    向列表中插入元素</span><br></pre></td></tr></table></figure><h3 id="SET-集合类型"><a href="#SET-集合类型" class="headerlink" title="SET(集合类型)"></a>SET(集合类型)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. SADD KEY MEMBER ...</span><br><span class="line">   添加元素</span><br><span class="line">   </span><br><span class="line">2. SREM KEY MEMBER ...</span><br><span class="line">   删除元素</span><br><span class="line">   </span><br><span class="line">3. SMEMBERS KEY</span><br><span class="line">   获得集合中所有元素</span><br><span class="line">   </span><br><span class="line">4. SISMEMBER KEY MEMBER</span><br><span class="line">   判断元素是否在集合中</span><br><span class="line">   </span><br><span class="line">5. SDIFF [KEY ...]</span><br><span class="line">    对多个集合进行差集运算</span><br><span class="line">    </span><br><span class="line">6. SINTER [KEY ...]</span><br><span class="line">   用来对多个集合执行交集运算</span><br><span class="line">   </span><br><span class="line">7. SUNION [KEY ...]</span><br><span class="line">   用来对多个集合实现并集运算</span><br><span class="line">   </span><br><span class="line">8. SCARD KEY</span><br><span class="line">   获得元素中的元素个数</span><br><span class="line">   </span><br><span class="line">9. SRANDMEMBER KEY [COUNT]</span><br><span class="line">   随机获得集合中元素</span><br><span class="line">   </span><br><span class="line">10. SPOP KEY</span><br><span class="line">    从集合中弹出一个元素</span><br></pre></td></tr></table></figure><h3 id="ZSET-有序集合"><a href="#ZSET-有序集合" class="headerlink" title="ZSET(有序集合)"></a>ZSET(有序集合)</h3><p>有序集合类型，在集合类型的基础上，有序集合类型为每个元素都关联了一个**分数[必须为浮点数]**。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. ZADD KEY SCORE MEMBER...</span><br><span class="line">   增加元素</span><br><span class="line">    </span><br><span class="line">2. ZSCORE KEY MEMBER</span><br><span class="line">   获得元素的分数</span><br><span class="line">   </span><br><span class="line">3. ZCARD KEY</span><br><span class="line">   获得集合中的元素数量</span><br><span class="line">   </span><br><span class="line">4. ZCOUNT KEY MIN MAX</span><br><span class="line">   获得指定分数范围内元素个数</span><br><span class="line">   </span><br><span class="line">5. ZREM KEY MEMBER ...</span><br><span class="line">   删除一个或多个元素</span><br><span class="line">   </span><br><span class="line">6. ZREMRANGEBYRANK KEY START STOP</span><br><span class="line">   按照元素分数从小到大排序，删除处在指定排名范围内的所有元素，并返回删除的元素数量</span><br><span class="line">   </span><br><span class="line">7. ZREMRSNGEBYSCORE KEY MIN MAX</span><br><span class="line">   按照分数范围删除元素</span><br><span class="line">   </span><br><span class="line">8. ZRANK KEY MEMBER [WITHSCOPES]</span><br><span class="line">    按照元素分数从小到大顺序获得指定的元素排名</span><br><span class="line">    </span><br><span class="line">9. ZREVRANK KEY MEMBER [WITHSCOPES]</span><br><span class="line">   按照元素分数从大到小顺序获得指定的元素排名  </span><br><span class="line">    </span><br><span class="line">10. ZINCRBY KEY INCREMENT MEMBER</span><br><span class="line">    增加某个元素分数</span><br><span class="line">    </span><br><span class="line">11. ZRANGEBYSCORE KEY MIN MAX [WITHSCOPES] [LIMT OFFSET]</span><br><span class="line">    返回分数在min和max之间的元素，可以在分数加上“c”符号表示不包含。和ZADD命令一样，-inf和+inf分别表示负无穷和正无穷 </span><br><span class="line">    LIMT OFFSET表示取值范围比如：LIMT 1 3 表示从第二个结果开始的3条数据</span><br><span class="line">    WITHSCOPES 参数可以使得返回数据格式由“元素1 ... 元素n” 变为 “元素1 分数1 ... 元素n 分数n”</span><br></pre></td></tr></table></figure><h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. MULTI</span><br><span class="line">   开始一个事务</span><br><span class="line">2. EXEC</span><br><span class="line">   执行事务</span><br><span class="line">   </span><br><span class="line">3. WATCH</span><br><span class="line">   可以监控一个或多个键，一旦键被修改或者删除之后的事务就不会被执行。监控一直持续到EXEC命令。</span><br><span class="line">   </span><br><span class="line">4. EXPIPE KEY SECONDS</span><br><span class="line">    设置键的过期时间单位：秒。成功返回1，失败返回0。</span><br><span class="line">    </span><br><span class="line">5. TTL KEY</span><br><span class="line">    返回键的剩余时间，单位：秒。不存在返回-2，存在不过期返回-1。</span><br><span class="line">    </span><br><span class="line">6. PERSIST</span><br><span class="line">   取消过期时间设定。</span><br><span class="line">   [注意:SET、GETSET 为键赋值也会清除过期时间]</span><br><span class="line">   </span><br><span class="line">7. PEXPIRE KEY SECONDS</span><br><span class="line">   设置键的过期时间单位：毫秒</span><br><span class="line">   </span><br><span class="line">8. PTTL</span><br><span class="line">   以毫秒返回键的剩余时间</span><br></pre></td></tr></table></figure><h3 id="Redis发布-订阅模式"><a href="#Redis发布-订阅模式" class="headerlink" title="Redis发布/订阅模式"></a>Redis发布/订阅模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. PUBLISH CHANNEL MESSAGE</span><br><span class="line">   发布消息命令</span><br><span class="line"></span><br><span class="line">2. SUBSCRIBE [CHANNEL ...]</span><br><span class="line">   订阅频道指令，执行SUBSCRIBE命令后，客户端进入订阅状态，在该状态下，客户端不能使用除SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE、PUNSUBSCRIBE这四个指令外的其他命令。</span><br><span class="line">   </span><br><span class="line">3. UNSUBSCRIBE [CHANNEL ...]</span><br><span class="line">   取消订阅频道,如果没有参数则取消所有订阅</span><br><span class="line">   </span><br><span class="line">4. PSUBSCRIBE [CHANNEL.?* ...]</span><br><span class="line">   订阅指定规则的频道 </span><br><span class="line">    </span><br><span class="line">5. PUNSUBSCRIBE [PATTERN ...]</span><br><span class="line">    取消符合规则的订阅频道，如果没有参数，则退订所有频道</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis可以存储键和五种不同的数据结构类型，分别为:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/p</summary>
      
    
    
    
    
    <category term="redis" scheme="https://yuer2016.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile指令详解</title>
    <link href="https://yuer2016.github.io/2021/07/25/Dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>https://yuer2016.github.io/2021/07/25/Dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-07-25T13:59:43.000Z</published>
    <updated>2021-07-25T14:05:20.926Z</updated>
    
    <content type="html"><![CDATA[<p>Dockfile是一种被Docker程序解释的脚本，Dockerfile由一条一条的指令组成，每条指令对应Linux下面的一条命令。Docker程序将这些Dockerfile指令翻译真正的Linux命令。Dockerfile有自己书写格式和支持的命令，Docker程序解决这些命令间的依赖关系，类似于Makefile。Docker程序将读取Dockerfile，根据指令生成定制的image。相比image这种黑盒子，Dockerfile这种显而易见的脚本更容易被使用者接受，它明确的表明image是怎么产生的。有了Dockerfile，当我们需要定制自己额外的需求时，只需在Dockerfile上添加或者修改指令，重新生成image即可，省去了敲命令的麻烦。<br>在 Dockerfile 中用到的命令有：</p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>FROM指定一个基础镜像， 一般情况下一个可用的 Dockerfile一定是 FROM 为第一个指令。至于image则可以是任何合理存在的image镜像。<br>FROM 一定是首个非注释指令 Dockerfile.<br>FROM 可以在一个 Dockerfile 中出现多次，以便于创建混合的images。<br>如果没有指定 tag ，latest 将会被指定为要使用的基础镜像版本。</p><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>这里是用于指定镜像制作者的信息</p><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>RUN命令将在当前image中执行任意合法命令并提交执行结果。命令执行提交后，就会自动执行Dockerfile中的下一个指令。<br>层级 RUN 指令和生成提交是符合Docker核心理念的做法。它允许像版本控制那样，在任意一个点，对image 镜像进行定制化构建。<br>RUN 指令缓存不会在下个命令执行时自动失效。比如 RUN apt-get dist-upgrade -y 的缓存就可能被用于下一个指令. –no-cache 标志可以被用于强制取消缓存使用。</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>ENV指令可以用于为docker容器设置环境变量<br>ENV设置的环境变量，可以使用 docker inspect命令来查看。同时还可以使用docker run –env <key>=<value>来修改环境变量。</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>USER 用来切换运行属主身份的。Docker 默认是使用 root，但若不需要，建议切换使用者身分，毕竟 root 权限太大了，使用上有安全的风险。</p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>WORKDIR 用来切换工作目录的。Docker 默认的工作目录是/，只有 RUN 能执行 cd 命令切换目录，而且还只作用在当下下的 RUN，也就是说每一个 RUN 都是独立进行的。如果想让其他指令在指定的目录下执行，就得靠 WORKDIR。WORKDIR 动作的目录改变是持久的，不用每个指令前都使用一次 WORKDIR。</p><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>COPY 将文件从路径 <src> 复制添加到容器内部路径 <dest>。</p><src>必须是想对于源文件夹的一个文件或目录，也可以是一个远程的url，<dest>是目标容器中的绝对路径。所有的新文件和文件夹都会创建UID 和 GID 。事实上如果 <src> 是一个远程文件URL，那么目标文件的权限将会是600。<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD 将文件从路径 <src> 复制添加到容器内部路径 <dest>。</p><p><src> 必须是想对于源文件夹的一个文件或目录，也可以是一个远程的url。<dest> 是目标容器中的绝对路径。<br>所有的新文件和文件夹都会创建UID 和 GID。事实上如果 <src> 是一个远程文件URL，那么目标文件的权限将会是600。</p><p>##VOLUME<br>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>EXPOSE 指令指定在docker允许时指定的端口进行转发。</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>Dockerfile.中只能有一个CMD指令。 如果你指定了多个，那么最后个CMD指令是生效的。<br>CMD指令的主要作用是提供默认的执行容器。这些默认值可以包括可执行文件，也可以省略可执行文件。<br>当你使用shell或exec格式时， CMD<br>会自动执行这个命令。</p><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>ONBUILD 的作用就是让指令延迟執行，延迟到下一个使用 FROM 的 Dockerfile 在建立 image 时执行，只限延迟一次。<br>ONBUILD 的使用情景是在建立镜像时取得最新的源码 (搭配 RUN) 与限定系统框架。</p><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>ARG是Docker1.9 版本才新加入的指令。<br>ARG 定义的变量只在建立 image 时有效，建立完成后变量就失效消失</p><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>定义一个 image 标签 Owner，并赋值，其值为变量 Name 的值。(LABEL Owner=$Name )</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>是指定 Docker image 运行成 instance (也就是 Docker container) 时，要执行的命令或者文件。</p><p>注意：</p><p>CMD 和 ENTRYPOINT 都能用来指定开始运行的程序，而且这两个命令都有两种不用的语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD ls -l</span><br><span class="line">OR</span><br><span class="line">CMD [<span class="string">&quot;ls&quot;</span>,<span class="string">&#x27;&#x27;</span>-l<span class="string">&quot;]</span></span><br></pre></td></tr></table></figure><p>对于第一种语法，docker 会自动加入“/bin/sh –c”到命令中，这样就有可能导致意想不到的行为。为了避免这种行为，我们推荐所有的 CMD 和 ENTRYPOINT 都应该使用第二种语法。<br>如果两个同时使用，请确定确定他们的含义没有错误。一般来说需要两个同时使用的情况只有 ENTRYPOINT 指定需要运行的 binary，CMD 给出运行的默认参数。</p><p><strong>尽量合并命令</strong></p><p>Dockerfile 中的每一个命令都会创建一个新的 layer，而一个容器能够拥有的最多 layer 数是有限制的。所以尽量将逻辑上连贯的命令合并可以减少 layer的层数，合并命令的方法可以包括将多个可以合并的命令（EXPOSE， ENV，VOLUME，COPY）合并。<br>Dockerfile 中的每一个命令都会创建一个新的 layer，而一个容器能够拥有的最多 layer 数是有限制的。所以尽量将逻辑上连贯的命令合并可以减少 layer 的层数，这也可以加快编译速度。<br>将多个可以合并的命令（RUN,EXPOSE, ENV,VOLUME,COPY）合并，比如：</p><p>合并前：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXOISE 80</span><br><span class="line">EXOISE 8080</span><br><span class="line">CMD <span class="built_in">cd</span> /tmp</span><br><span class="line">CMD ls</span><br></pre></td></tr></table></figure><p>合并后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXOISE 80 8080</span><br><span class="line">CMD <span class="built_in">cd</span> /tmp &amp;&amp; ls</span><br></pre></td></tr></table></figure><p>ADD命令和 COPY 命令在很大层度上功能是一样的。但是 COPY 语义更加直接，所以我们推荐尽量使用 COPY 命令。唯一例外的是 ADD 命令自带解压功能，如果需要拷贝并解压一个文件到镜像中，那么我们可以使用 ADD 命令。除此之外，我们都推荐使用 COPY 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD 1.1.1.100:1234/jdk-8u74-linux-x64.tar.gz /usr/<span class="built_in">local</span>/</span><br></pre></td></tr></table></figure><p>USER的使用<br>Docker 默认所有的应用都会跑在容器的 root user 底下，但是这样会造成一些潜在的安全隐患。在 production 环境跑的 Container 最好是通过USER命令跑在非特权用户底下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Dockfile是一种被Docker程序解释的脚本，Dockerfile由一条一条的指令组成，每条指令对应Linux下面的一条命令。Docker程序将这些Dockerfile指令翻译真正的Linux命令。Dockerfile有自己书写格式和支持的命令，Docker程序解决这</summary>
      
    
    
    
    
    <category term="docker" scheme="https://yuer2016.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>OpenResty 安装部署Vue 前端</title>
    <link href="https://yuer2016.github.io/2021/07/25/OpenResty-%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2Vue-%E5%89%8D%E7%AB%AF/"/>
    <id>https://yuer2016.github.io/2021/07/25/OpenResty-%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2Vue-%E5%89%8D%E7%AB%AF/</id>
    <published>2021-07-25T13:48:09.000Z</published>
    <updated>2021-07-25T13:55:29.257Z</updated>
    
    <content type="html"><![CDATA[<ol><li>下载安装包 </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://openresty.org/download/openresty-1.17.8.2.tar.gz</span><br></pre></td></tr></table></figure><ol start="2"><li>安装依赖包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install openssl openssl-devel pcre-devel </span><br></pre></td></tr></table></figure><ol start="3"><li>解压openresty包编译安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf openresty-VERSION.tar.gz </span><br><span class="line"><span class="built_in">cd</span> openresty-VERSION/ </span><br><span class="line">./configure -j2 make -j2 </span><br><span class="line">sudo make install </span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/openresty/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><ol start="4"><li>创建Vue前端部署目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/work &amp;&amp; <span class="built_in">cd</span> ~/work </span><br><span class="line">mkdir logs/ conf/</span><br></pre></td></tr></table></figure><ol start="5"><li>启动Vue前端项目</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/openresty/nginx/sbin:<span class="variable">$PATH</span></span><br><span class="line">nginx -p <span class="built_in">pwd</span>/ -c conf/nginx.conf</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;下载安装包 &lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td c</summary>
      
    
    
    
    
    <category term="openresty vue" scheme="https://yuer2016.github.io/tags/openresty-vue/"/>
    
  </entry>
  
  <entry>
    <title>Java 代码动态化</title>
    <link href="https://yuer2016.github.io/2021/07/25/Java-%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E5%8C%96/"/>
    <id>https://yuer2016.github.io/2021/07/25/Java-%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E5%8C%96/</id>
    <published>2021-07-25T13:37:17.000Z</published>
    <updated>2021-07-25T13:45:54.176Z</updated>
    
    <content type="html"><![CDATA[<p>基本上，有四个步骤可以使Java代码动态化:</p><ol><li>部署选定的源代码并监视文件更改</li><li>在运行时编译Java代码</li><li>在运行时加载/重新加载Java类</li><li>将最新的类链接到其调用者</li></ol><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>要开始编写一些动态代码，我们必须回答的第一个问题是：“代码的哪一部分应该是动态的？整个应用程序还是某些类？”从技术上讲，没有什么限制。您可以在运行时加载/重新加载任何Java类。但是在大多数情况下，只有部分代码需要这种级别的灵活性。</p><p>在接口的后面，只要符合接口定义的协定，就可以自由更改实现。这正是我们动态类所需的质量。简而言之：选择实现类作为动态类。</p><h3 id="监视源代码修改"><a href="#监视源代码修改" class="headerlink" title="监视源代码修改"></a>监视源代码修改</h3><p>通过比较修改时间戳和文件大小，可以检测到文件更改。 对于我们的示例，每次在Postman接口上调用方法时，都会对PostmanImpl.java进行检查。 或者，您可以在后台生成守护程序线程以定期检查文件更改。 这可能会为大型应用程序带来更好的性能。</p><h3 id="在运行时编译Java代码"><a href="#在运行时编译Java代码" class="headerlink" title="在运行时编译Java代码"></a>在运行时编译Java代码</h3><p>在检测到源代码更改后，我们来解决编译问题。 通过将实际工作委派给现有的Java编译器，运行时编译可以轻而易举。 有许多Java编译器可供使用，但是在本文中，我们使用Sun的Java Platform Standard Edition中包含的Javac编译器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errorCode = com.sun.tools.javac.Main.compile(<span class="keyword">new</span> String[] &#123;</span><br><span class="line">            <span class="string">&quot;-classpath&quot;</span>, <span class="string">&quot;bin&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-d&quot;</span>, <span class="string">&quot;/temp/dynacode_classes&quot;</span>,</span><br><span class="line">            <span class="string">&quot;dynacode/sample/PostmanImpl.java&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p>com.sun.tools.javac.Main类是Javac编译器的编程接口。 它提供了编译Java源文件的静态方法。 执行上面的语句与从命令行以相同的参数运行javac具有相同的效果。 它使用指定的类路径bin编译源文件dynacode / sample / PostmanImpl.java，并将其类文件输出到目标目录/ temp / dynacode_classes。 返回一个整数作为错误代码。 零意味着成功；零意味着成功。 其他数字表示出了问题。</p><p>com.sun.tools.javac.Main 类还提供了另一个compile（）方法，该方法接受附加的PrintWriter参数，如下面的代码所示。 如果编译失败，则会将详细的错误消息写入PrintWriter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Defined in com.sun.tools.javac.Main</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compile</span><span class="params">(String[] args)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compile</span><span class="params">(String[] args, PrintWriter out)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="在运行时加载-重新加载Java类"><a href="#在运行时加载-重新加载Java类" class="headerlink" title="在运行时加载/重新加载Java类"></a>在运行时加载/重新加载Java类</h3><p>必须先加载已编译的类，然后才能生效。 Java在类加载方面很灵活。 它定义了一个全面的类加载机制，并提供了一些类加载器的实现。</p><p>下面的示例代码显示了如何加载和重新加载类。 基本思想是使用我们自己的URLClassLoader加载动态类。 每当更改并重新编译源文件时，我们都会丢弃旧的类（以供以后进行垃圾回收），并创建一个新的URLClassLoader来再次加载该类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The dir contains the compiled classes.</span></span><br><span class="line">    File classesDir = <span class="keyword">new</span> File(<span class="string">&quot;/temp/dynacode_classes/&quot;</span>);</span><br><span class="line">    <span class="comment">// The parent classloader</span></span><br><span class="line">    ClassLoader parentLoader = Postman.class.getClassLoader();</span><br><span class="line">    <span class="comment">// Load class &quot;sample.PostmanImpl&quot; with our own classloader.</span></span><br><span class="line">    URLClassLoader loader1 = <span class="keyword">new</span> URLClassLoader(</span><br><span class="line">            <span class="keyword">new</span> URL[] &#123; classesDir.toURL() &#125;, parentLoader);</span><br><span class="line">    Class cls1 = loader1.loadClass(<span class="string">&quot;sample.PostmanImpl&quot;</span>);</span><br><span class="line">    Postman postman1 = (Postman) cls1.newInstance();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke on postman1 ...</span></span><br><span class="line"><span class="comment">     * Then PostmanImpl.java is modified and recompiled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// Reload class &quot;sample.PostmanImpl&quot; with a new classloader.</span></span><br><span class="line">    URLClassLoader loader2 = <span class="keyword">new</span> URLClassLoader(</span><br><span class="line">            <span class="keyword">new</span> URL[] &#123; classesDir.toURL() &#125;, parentLoader);</span><br><span class="line">    Class cls2 = loader2.loadClass(<span class="string">&quot;sample.PostmanImpl&quot;</span>);</span><br><span class="line">    Postman postman2 = (Postman) cls2.newInstance();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Work with postman2 from now on ...</span></span><br><span class="line"><span class="comment">     * Don&#x27;t worry about loader1, cls1, and postman1</span></span><br><span class="line"><span class="comment">     * they will be garbage collected automatically.</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><p>创建自己的类加载器时，请注意parentLoader。 基本上，规则是父类加载器必须提供子类加载器所需的所有依赖项。 因此，在示例代码中，动态类PostmanImpl依赖于接口Postman。 这就是为什么我们使用Postman的类加载器作为父类加载器。</p><p>我们距离完成动态代码还有一步之遥。 回想一下前面介绍的示例。 在那里，动态类重新加载对其调用者是透明的。 但是在上面的示例代码中，当代码更改时，我们仍然必须将服务实例从postman1更改为postman2。 第四步（也是最后一步）将消除此手动更改的需要。</p><h3 id="将最新的类链接到其调用者"><a href="#将最新的类链接到其调用者" class="headerlink" title="将最新的类链接到其调用者"></a>将最新的类链接到其调用者</h3><p>如何使用静态引用访问最新的动态类？ 显然，直接（正常）引用动态类的对象不会成功。 我们需要在客户端和动态类之间建立一个代理。</p><p>在此，代理是充当动态类的访问接口的类。 客户端不直接调用动态类；而是直接调用动态类。 代理代替。 然后，代理将调用转发到后端动态类。</p><p>Java Reflection API包含一个用于创建代理的便捷实用程序。 类java.lang.reflect.Proxy提供了静态方法，使您可以为任何Java接口创建代理实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler handler = <span class="keyword">new</span> DynaCodeInvocationHandler(...);</span><br><span class="line">    Postman proxy = (Postman) Proxy.newProxyInstance(</span><br><span class="line">                Postman.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123; Postman.class &#125;,</span><br><span class="line">                handler);</span><br></pre></td></tr></table></figure><p>返回的代理是匿名类的对象，该匿名类与Postman接口（newProxyInstance（）方法的第一个参数）共享相同的类加载器，并实现Postman接口（第二个参数）。 代理实例上的方法调用将分派到处理程序的invoke（）方法（第三个参数）。 处理程序的实现可能如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynaCodeInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Get an instance of the up-to-date dynamic class</span></span><br><span class="line">        Object dynacode = getUpToDateInstance();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Forward the invocation</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(dynacode, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invoke（）方法获取最新动态类的实例，并将调用转发给它。 如果动态类的源文件已被修改，则这可能涉及源代码编译和类重载。</p><p>现在，我们已经完成了Postman服务的动态代码。 客户端创建服务的代理，并通过该代理调用方法DeliveryMessage（）。 代理上的每次调用都分派到DynaCodeInvocationHandler类的invoke（）方法。 在该方法中，首先获得了最新的服务实现，其中可能涉及必要的源代码编译和类重载。 然后，调用前进到实现以进行实际处理。</p><p>最后，我想讨论一下动态代码的价值和应用：动态代码可以快速响应按需更改请求。它可用于实现不时变化的真正的动态服务和业务规则，并替换工作流任务节点使用的嵌入式脚本。动态代码还简化了应用程序维护，并大大减少了由于应用程序重新部署而造成的停机。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基本上，有四个步骤可以使Java代码动态化:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;部署选定的源代码并监视文件更改&lt;/li&gt;
&lt;li&gt;在运行时编译Java代码&lt;/li&gt;
&lt;li&gt;在运行时加载/重新加载Java类&lt;/li&gt;
&lt;li&gt;将最新的类链接到其调用者&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 </summary>
      
    
    
    
    
    <category term="java" scheme="https://yuer2016.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>centos7 安装 docker</title>
    <link href="https://yuer2016.github.io/2021/07/25/centos7-%E5%AE%89%E8%A3%85-docker/"/>
    <id>https://yuer2016.github.io/2021/07/25/centos7-%E5%AE%89%E8%A3%85-docker/</id>
    <published>2021-07-25T13:30:59.000Z</published>
    <updated>2021-07-25T13:34:19.111Z</updated>
    
    <content type="html"><![CDATA[<h3 id="检查安装依赖库"><a href="#检查安装依赖库" class="headerlink" title="检查安装依赖库"></a>检查安装依赖库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">device-mapper-persistent-data</span><br><span class="line">lvm2</span><br></pre></td></tr></table></figure><h3 id="检查添加docker-yum源"><a href="#检查添加docker-yum源" class="headerlink" title="检查添加docker yum源"></a>检查添加docker yum源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager</span><br><span class="line">--add-repo</span><br><span class="line">https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><h3 id="启动docker服务"><a href="#启动docker服务" class="headerlink" title="启动docker服务"></a>启动docker服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="将docker设置为开机启动"><a href="#将docker设置为开机启动" class="headerlink" title="将docker设置为开机启动"></a>将docker设置为开机启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker.service</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;检查安装依赖库&quot;&gt;&lt;a href=&quot;#检查安装依赖库&quot; class=&quot;headerlink&quot; title=&quot;检查安装依赖库&quot;&gt;&lt;/a&gt;检查安装依赖库&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    
    <category term="centos  docker" scheme="https://yuer2016.github.io/tags/centos-docker/"/>
    
  </entry>
  
  <entry>
    <title>docker 安装 mysql5.7</title>
    <link href="https://yuer2016.github.io/2021/07/25/docker-%E5%AE%89%E8%A3%85-mysql5-7/"/>
    <id>https://yuer2016.github.io/2021/07/25/docker-%E5%AE%89%E8%A3%85-mysql5-7/</id>
    <published>2021-07-25T13:10:48.000Z</published>
    <updated>2021-07-25T13:29:56.538Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>拉取官方镜像(我们这里选择5.7,如果不写后面的版本号则会自动拉取最新版）</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull mysql:5.7</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>检查是否拉取成功</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images </span><br></pre></td></tr></table></figure></li><li><p>一般来说数据库容器不需要建立目录映射</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br></pre></td></tr></table></figure></li></ol><p>–name：容器名，此处命名为mysql<br>-e：配置信息，此处配置mysql的root用户的登陆密码<br>-p：端口映射，此处映射 主机3306端口 到 容器的3306端口<br>-d：后台运行容器，保证在退出终端后容器继续运行</p><ol start="4"><li><p>检查容器是否正确运行 </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br></pre></td></tr></table></figure></li><li><p>进入docker本地连接mysql客户端</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker <span class="built_in">exec</span> -it mysql bash mysql -uroot -p123456</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;拉取官方镜像(我们这里选择5.7,如果不写后面的版本号则会自动拉取最新版）&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    
    <category term="docker mysql" scheme="https://yuer2016.github.io/tags/docker-mysql/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用教程</title>
    <link href="https://yuer2016.github.io/2021/07/25/hello-world/"/>
    <id>https://yuer2016.github.io/2021/07/25/hello-world/</id>
    <published>2021-07-25T11:58:47.388Z</published>
    <updated>2021-07-25T13:26:59.600Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
